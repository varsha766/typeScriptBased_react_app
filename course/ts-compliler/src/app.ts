// Decorators in typescript
/**
 * Decorators are special kind of declaration that can be
 * attached to a class declaration, method, accessor,
 * property, or parameter.
 * Decorator use the form @expression, where expression must evalute to function
 * that get called at runtime with information about the
 * declaration
 * for writting decorator in TS    "experimentalDecorators": true,                   /* Enable experimental support for legacy experimental decorators and "emitDecoratorMetadata": true,  should
 * be set to true
 * */
// writing decorator
// For using particular decorator on class it must take at least one argument i.e constructor funcction

// decortor is nothing but a function
function FirstDecorator(constructor: Function) {
  console.log("Decorator Invoked");
  console.log(constructor);
}
@FirstDecorator
class Aircraft {
  constructor(public _aircraftModel: string, private pilot: string) {
    console.log(" constructor function is invoked ");
  }

  public pilotName() {
    console.log(this.pilot);
  }

  public get aircraftModel() {
    return this._aircraftModel;
  }
}

// when decorator get invoked
/**
 * Decorators are invoked only once throughout the application execution process
 * They are invoked at the time when class is defined by typescript at the runtime
 * but not when the class is instantiated
 */

const aircraft = new Aircraft("Airbus A380", "John");

// advantage of decorator is we can add properties and methods to the prototype of the object generated by the class

enum Manufacturer {
  boeing = "boeing",
  airbus = "airbus",
}

function AircraftManufacturer(manufacturer: Manufacturer) {
  return (target: Function) => {
    if (manufacturer === Manufacturer.airbus) {
      target.prototype.origin = "United state of America";
      target.prototype.manufacturer = Manufacturer.airbus;
      target.prototype.type = "Jet";
    } else {
      target.prototype.origin = "France";
      target.prototype.manufacturer = Manufacturer.boeing;
      target.prototype.type = "Helicopter";
    }
  };
}

interface AircraftInterface {
  _aircraftModel: string;
  prototype?: any;
  origin?: string;
  manufacturer?: string;
  type?: string;
}

@AircraftManufacturer(Manufacturer.airbus)
class Airplane implements AircraftInterface {
  constructor(public _aircraftModel: string, private pilot: string) {
    console.log(" constructor function is invoked ");
  }
  public pilotName() {
    console.log(this.pilot);
  }

  public get aircraftModel() {
    return this._aircraftModel;
  }
}

const airplane: AircraftInterface = new Airplane("Airbus A380", "John");
// console.log(airplane);
// console.log(airplane.manufacturer);
// interface for prototype
/**
 * We are getting error `Property 'manufacturer' does not exist on type 'Airplane'.` if we do console.log(airplane.manufacturer)
 * because we have added  manufacturer tot he prototype using decorater rather adding them to class
 */

// adding function to prototype

function AircraftManufacturer2(manufacturer: Manufacturer) {
  return (target: Function) => {
    if (manufacturer === Manufacturer.airbus) {
      target.prototype.origin = "United state of America";
      target.prototype.manufacturer = Manufacturer.airbus;
      target.prototype.type = "Jet";
      target.prototype.airBusMethod = () => {
        console.log(" Function performed by airbus");
      };
    } else {
      target.prototype.origin = "France";
      target.prototype.manufacturer = Manufacturer.boeing;
      target.prototype.type = "Helicopter";
      target.prototype.boeingMethod = () => {
        console.log(" Function performed by boeing");
      };
    }
  };
}
interface AircraftInterface2 {
  _aircraftModel: string;
  pilotName: () => void;
  prototype?: any;
  origin?: string;
  manufacturer?: string;
  type?: string;
  airBusMethod?: () => void;
  boeingMethod?: () => void;
}

@AircraftManufacturer2(Manufacturer.airbus)
class Airplane2 implements AircraftInterface2 {
  constructor(public _aircraftModel: string, private pilot: string) {}
  public pilotName() {
    console.log(this.pilot);
  }

  public get aircraftModel() {
    return this._aircraftModel;
  }
}
const airplane2: AircraftInterface2 = new Airplane2("Airbus A380", "John");
airplane2.airBusMethod
  ? airplane2.airBusMethod()
  : console.log("Method does not exists");

// use of decorator to multiple classes

@AircraftManufacturer2(Manufacturer.boeing)
class Helicopter implements AircraftInterface2 {
  constructor(public _aircraftModel: string, private pilot: string) {}
  public pilotName() {
    console.log(this.pilot);
  }

  public get aircraftModel() {
    return this._aircraftModel;
  }
}

const helicopter: AircraftInterface2 = new Helicopter("H380", "Mark");
//console.log(helicopter);

//How to use decorator with method of classes
// Method decorator takes three argument
//1. classPrototype:Object,   class prototype
//2. methodName:string   //method name itself
//3. descriptor:PrototyDescriptor   // descriptor of the method
function MethodDecorator(
  classPrototype: Object,
  methodName: string,
  descriptor: PropertyDescriptor
) {
  console.log(classPrototype, methodName, descriptor);
  // we can set the value of descriptor in decorator itself
  descriptor.writable = false;
}

class Airplane3 implements AircraftInterface2 {
  constructor(public _aircraftModel: string, private pilot: string) {}
  @MethodDecorator
  public pilotName() {
    console.log(this.pilot);
  }
  public get aircraftModel() {
    return this._aircraftModel;
  }
}

const airplane3: AircraftInterface2 = new Airplane3("Airbus A380", "Varsha");
//airplane3.pilotName = () => console.log("Function changed");
//airplane3.pilotName(); // we can not change the function because pilotName is set to writable:false in its descriptor

// static method decorator
// in static method decorator we pass constructor
// for all static member the first argument that we get is constructor method
function StaticMethodDecorator(
  constructor: Object,
  methodName: string,
  descriptor: PropertyDescriptor
) {
  console.log(constructor, methodName, descriptor);
  // we can set the value of descriptor in decorator itself
  descriptor.writable = false;
}
class NewAirplane implements AircraftInterface2 {
  constructor(public _aircraftModel: string, private pilot: string) {}
  @StaticMethodDecorator
  public static seatCount(): void {
    console.log("156");
  }

  @MethodDecorator
  public pilotName() {
    console.log(this.pilot);
  }
  public get aircraftModel() {
    return this._aircraftModel;
  }
}

const newResult = new NewAirplane("ATC 1231", "nandani");

// decorator factory
// Decorator factory is nothing but a function that encapsulates the original decorator function nd returns the original function
// convert FirstDecorator to decorator factory
// decorator factory can be invoked using parenthesis
function FirstDecoratorFactory(name: string) {
  return function (constructor: Function) {
    console.log(`${name} Invoked`);
    console.log(constructor);
  };
}

@FirstDecoratorFactory("First decorator")
class NewAirplane2 implements AircraftInterface2 {
  constructor(public _aircraftModel: string, private pilot: string) {}
  public static seatCount(): void {
    console.log("156");
  }

  public pilotName() {
    console.log(this.pilot);
  }
  public get aircraftModel() {
    return this._aircraftModel;
  }
}

const result = new NewAirplane2("ATC 1231", "nandani");
